#include <iostream>
#include <math.h>
#include <stdlib.h>
#include <fstream>

using namespace std;

int main() {
    int n, m;
    //Создаем массив
    ifstream f("matrix.txt");
    f >> n;
    cout << "Number of equations = " << n << endl;
    cout << "Number of variables = " << n << endl;
    m = n + 1;                  //Расширенная матрица
    double **A = new double *[n]; //Выделяем память под строки
    for (int i = 0; i < n; i++)
        A[i] = new double[m];    //Под столбцы
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            f >> A[i][j];
        }
    }
    f.close();

    //Вывод на экран
    cout << "Matrix A: " << endl;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            cout << A[i][j] << " ";
        cout << endl;
    }
    cout << endl;

    /*-----------------------------------Прямой ход---------------------------------------
                           A         | b
     Допустим есть матрица [2] -1   0 | 3
                            5   4   2 | 6
                            0   1  -3 | 2
     на первом проходе
     y[1] = [2], т.е. A[0][0]
     a[0] или alpha 0 = - с1 / y[1], т.е берем отрицание от дроби и
                                     делим элемент справа от y на y
     b[0] или beta 0 = d1 / y[1], т.е. первый элемент из вектора b (в нашем случае это 3)
                                       делим на y
     получим:
     a[0] = - (-1/2) = 0.5
     b[0] = 3/2 = 1.5
                                                                                           */
    double y, a[n], B[n], x[n];//Дополнительные массивы
    y = A[0][0];               //Инициализируем первый y
    a[0] = -A[0][1] / y;       //Инициализируем первую alpha
    B[0] = A[0][m-1] / y;      //Инициализируем первую beta
    cout <<y <<' ' <<a[0] << ' ' <<B[0] <<endl; //Выводим промежуточные действия
    for (int i = 1; i < n; i++) {
     y = A[i][i] + A[i][i - 1] * a[i - 1];
    /*
     y считается следующим образом:
     Допустим есть матрица 2  -1   0 | 3
                           5 [4]   2 | 6
                           0   1  -3 | 2
     Спускаемся по диагонали вниз, тобишь второй y у нас будет [4]
     Потом прибавляем произведение элемента стоящего слева [4]. то есть 5
     и alpha, которое у нас получается на предыдущем шаге, в нашем случае это 0.5
     y[1] = 4 + 5 * 0.5 = 6.5
     alpha считаем по той же схеме, что и в иниадизации, тобишь элемент справа от y
                                                         делим на y
     a[1] = -2/6.5
     beta считаем как раность элемента, стоящего под y и произведения alpha
     полученного в ЭТОМ проходе и beta из ПРЕДЫДУЩЕГО прохода, все это делим на соответствующий y
     beta[1] = (6 - 5 * 1.5) / 6.5
     */
     a[i] = -A[i][i + 1] / y;
     B[i] = (A[i][m-1] - A[i][i - 1] * B[i - 1]) / y;
     cout <<y <<' ' <<a[i] << ' ' <<B[i] <<endl; //Выводим промежуточные данные
    }
    /*-----------------------------------Прямой ход---------------------------------------*/

    /*-----------------------------------Обратный ход---------------------------------------*/
    for (int i = n - 1; i >= 0; i--) {
        x[i] = a[i] * x[i + 1] + B[i];
        /*
         На обратном ходу вычисляем сверху вниз каждое значение x
         В нашем случае так как уравнений 3, то и количество решеней 3
         начинаем с расчета последнего x
         Последний x всегда равен последнему значению beta
         Начиная с предпоследнего считаем так:
         x[1] = alpha[1] * x[2] + beta[1]
         В дальнейшем просто играем с коэффициентами
         */
    }
    /*-----------------------------------Обратный ход---------------------------------------*/
    //Выводим решения
    cout <<endl <<"Answer" <<endl;
    for (int i = 0; i < n; i++)
        cout << x[i] << " ";
    cout << endl;
    //Выводим решения в файл
    ofstream out ("answer.txt");
    for (int i = 0; i <n; i++)
    {
        out << x[i] << ' ';
    }
    out.close();
    system("pause");
    return 0;
}
